<!doctype html><html lang=en><head><title>bloom-filter · zen
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Zen Yu"><meta name=description content="Bloom Filter(布隆过滤器) Link to heading 布隆过滤器（Bloom Filter）是 1970 年由布隆提出的，是一种高效的概率型数据结构。它实际上是一个很长的二进制向量和一系列随机映射函数。用于测试一个元素是否属于一个集合。它特别适用于需要快速检查一个元素是否在一个大集合中的场景。布隆过滤器通过牺牲一定的准确性（存在误判的可能性）来换取空间效率和查询速度。
布隆过滤器简介 Link to heading 优点和缺点 Link to heading 优点 Link to heading 空间效率高：布隆过滤器相比传统的数据结构（如哈希表、集合），在相同的数据量下占用的内存要少得多。 查询速度快：布隆过滤器的查询时间复杂度为 O(k)，其中 k 是哈希函数的数量，通常是常数。 缺点 Link to heading 存在误判：布隆过滤器会存在误判的可能性，即可能会判断一个元素在集合中，但实际并不在。无法判断元素“肯定不存在”的情况。 无法删除元素：一旦元素被添加到布隆过滤器中，无法删除。如果要删除，需要使用改进的版本，如计数布隆过滤器（Counting Bloom Filter）。 应用场景 Link to heading 缓存系统：布隆过滤器常用于缓存系统中，快速判断一个请求是否已经被缓存，以减少不必要的磁盘访问。 网络爬虫：用于判断一个URL是否已经被访问过，避免重复抓取。 数据库：在数据库查询中，用于快速判断一个键值是否存在于数据库中，以减少不必要的查询。 实际实现方式 Link to heading import mmh3 from bitarray import bitarray class BloomFilter: def __init__(self, size, hash_count): self.size = size self.hash_count = hash_count self.bit_array = bitarray(size) self.bit_array.setall(0) def add(self, item): for i in range(self."><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="bloom-filter"><meta name=twitter:description content="Bloom Filter(布隆过滤器) Link to heading 布隆过滤器（Bloom Filter）是 1970 年由布隆提出的，是一种高效的概率型数据结构。它实际上是一个很长的二进制向量和一系列随机映射函数。用于测试一个元素是否属于一个集合。它特别适用于需要快速检查一个元素是否在一个大集合中的场景。布隆过滤器通过牺牲一定的准确性（存在误判的可能性）来换取空间效率和查询速度。
布隆过滤器简介 Link to heading 优点和缺点 Link to heading 优点 Link to heading 空间效率高：布隆过滤器相比传统的数据结构（如哈希表、集合），在相同的数据量下占用的内存要少得多。 查询速度快：布隆过滤器的查询时间复杂度为 O(k)，其中 k 是哈希函数的数量，通常是常数。 缺点 Link to heading 存在误判：布隆过滤器会存在误判的可能性，即可能会判断一个元素在集合中，但实际并不在。无法判断元素“肯定不存在”的情况。 无法删除元素：一旦元素被添加到布隆过滤器中，无法删除。如果要删除，需要使用改进的版本，如计数布隆过滤器（Counting Bloom Filter）。 应用场景 Link to heading 缓存系统：布隆过滤器常用于缓存系统中，快速判断一个请求是否已经被缓存，以减少不必要的磁盘访问。 网络爬虫：用于判断一个URL是否已经被访问过，避免重复抓取。 数据库：在数据库查询中，用于快速判断一个键值是否存在于数据库中，以减少不必要的查询。 实际实现方式 Link to heading import mmh3 from bitarray import bitarray class BloomFilter: def __init__(self, size, hash_count): self.size = size self.hash_count = hash_count self.bit_array = bitarray(size) self.bit_array.setall(0) def add(self, item): for i in range(self."><meta property="og:url" content="/posts/experience/bloom-filter/"><meta property="og:site_name" content="zen"><meta property="og:title" content="bloom-filter"><meta property="og:description" content="Bloom Filter(布隆过滤器) Link to heading 布隆过滤器（Bloom Filter）是 1970 年由布隆提出的，是一种高效的概率型数据结构。它实际上是一个很长的二进制向量和一系列随机映射函数。用于测试一个元素是否属于一个集合。它特别适用于需要快速检查一个元素是否在一个大集合中的场景。布隆过滤器通过牺牲一定的准确性（存在误判的可能性）来换取空间效率和查询速度。
布隆过滤器简介 Link to heading 优点和缺点 Link to heading 优点 Link to heading 空间效率高：布隆过滤器相比传统的数据结构（如哈希表、集合），在相同的数据量下占用的内存要少得多。 查询速度快：布隆过滤器的查询时间复杂度为 O(k)，其中 k 是哈希函数的数量，通常是常数。 缺点 Link to heading 存在误判：布隆过滤器会存在误判的可能性，即可能会判断一个元素在集合中，但实际并不在。无法判断元素“肯定不存在”的情况。 无法删除元素：一旦元素被添加到布隆过滤器中，无法删除。如果要删除，需要使用改进的版本，如计数布隆过滤器（Counting Bloom Filter）。 应用场景 Link to heading 缓存系统：布隆过滤器常用于缓存系统中，快速判断一个请求是否已经被缓存，以减少不必要的磁盘访问。 网络爬虫：用于判断一个URL是否已经被访问过，避免重复抓取。 数据库：在数据库查询中，用于快速判断一个键值是否存在于数据库中，以减少不必要的查询。 实际实现方式 Link to heading import mmh3 from bitarray import bitarray class BloomFilter: def __init__(self, size, hash_count): self.size = size self.hash_count = hash_count self.bit_array = bitarray(size) self.bit_array.setall(0) def add(self, item): for i in range(self."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-21T15:50:05+08:00"><meta property="article:modified_time" content="2024-08-21T15:50:05+08:00"><meta name=google-adsense-account content="ca-pub-8308665726033207"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-webfont/1.7.0/lxgwwenkai-regular.min.css integrity="sha512-Fzvxn9FrR1aKr/Z4Pg9KpnVHCsJoq2QwSu1juU2oQ6wDUkUMk3qQUUWKgFjk0m0LzCamIJVOkg5zeyNX5I1wgA==" crossorigin=anonymous referrerpolicy=no-referrer><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8308665726033207" crossorigin=anonymous></script><link rel=canonical href=/posts/experience/bloom-filter/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.388ff1c4d59a8bfff75a64afc1e755b8f3ab54ea6797a4b9907934a03e4e782b.css integrity="sha256-OI/xxNWai//3WmSvwedVuPOrVOpnl6S5kHk0oD5OeCs=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/logo.webp sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>zen
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/selfs/>学习</a></li><li class=navigation-item><a class=navigation-link href=/posts/>技术</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=/posts/experience/bloom-filter/>bloom-filter</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-08-21T15:50:05+08:00>August 21, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
One-minute read</span></div></div></header><div class=post-content><h1 id=bloom-filter布隆过滤器>Bloom Filter(布隆过滤器)
<a class=heading-link href=#bloom-filter%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>布隆过滤器（Bloom Filter）是 1970 年由布隆提出的，是一种高效的概率型数据结构。它实际上是一个很长的二进制向量和一系列随机映射函数。用于测试一个元素是否属于一个集合。它特别适用于需要快速检查一个元素是否在一个大集合中的场景。布隆过滤器通过牺牲一定的准确性（存在误判的可能性）来换取空间效率和查询速度。</p><h2 id=布隆过滤器简介>布隆过滤器简介
<a class=heading-link href=#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8%e7%ae%80%e4%bb%8b><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h2 id=优点和缺点>优点和缺点
<a class=heading-link href=#%e4%bc%98%e7%82%b9%e5%92%8c%e7%bc%ba%e7%82%b9><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=优点>优点
<a class=heading-link href=#%e4%bc%98%e7%82%b9><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li>空间效率高：布隆过滤器相比传统的数据结构（如哈希表、集合），在相同的数据量下占用的内存要少得多。</li><li>查询速度快：布隆过滤器的查询时间复杂度为 O(k)，其中 k 是哈希函数的数量，通常是常数。</li></ul><h3 id=缺点>缺点
<a class=heading-link href=#%e7%bc%ba%e7%82%b9><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li>存在误判：布隆过滤器会存在误判的可能性，即可能会判断一个元素在集合中，但实际并不在。无法判断元素“肯定不存在”的情况。</li><li>无法删除元素：一旦元素被添加到布隆过滤器中，无法删除。如果要删除，需要使用改进的版本，如计数布隆过滤器（Counting Bloom Filter）。</li></ul><h2 id=应用场景>应用场景
<a class=heading-link href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li>缓存系统：布隆过滤器常用于缓存系统中，快速判断一个请求是否已经被缓存，以减少不必要的磁盘访问。</li><li>网络爬虫：用于判断一个URL是否已经被访问过，避免重复抓取。</li><li>数据库：在数据库查询中，用于快速判断一个键值是否存在于数据库中，以减少不必要的查询。</li></ul><h2 id=实际实现方式>实际实现方式
<a class=heading-link href=#%e5%ae%9e%e9%99%85%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>mmh3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>bitarray</span> <span class=kn>import</span> <span class=n>bitarray</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BloomFilter</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>hash_count</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>hash_count</span> <span class=o>=</span> <span class=n>hash_count</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>bit_array</span> <span class=o>=</span> <span class=n>bitarray</span><span class=p>(</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>bit_array</span><span class=o>.</span><span class=n>setall</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>hash_count</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>index</span> <span class=o>=</span> <span class=n>mmh3</span><span class=o>.</span><span class=n>hash</span><span class=p>(</span><span class=n>item</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>bit_array</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>check</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>hash_count</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>index</span> <span class=o>=</span> <span class=n>mmh3</span><span class=o>.</span><span class=n>hash</span><span class=p>(</span><span class=n>item</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>bit_array</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用示例</span>
</span></span><span class=line><span class=cl><span class=n>bf</span> <span class=o>=</span> <span class=n>BloomFilter</span><span class=p>(</span><span class=mi>5000</span><span class=p>,</span> <span class=mi>7</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>bf</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=s2>&#34;hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>bf</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=s2>&#34;world&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>bf</span><span class=o>.</span><span class=n>check</span><span class=p>(</span><span class=s2>&#34;hello&#34;</span><span class=p>))</span>  <span class=c1># 输出: True</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>bf</span><span class=o>.</span><span class=n>check</span><span class=p>(</span><span class=s2>&#34;world&#34;</span><span class=p>))</span>  <span class=c1># 输出: True</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>bf</span><span class=o>.</span><span class=n>check</span><span class=p>(</span><span class=s2>&#34;python&#34;</span><span class=p>))</span> <span class=c1># 输出: False（可能为 False，但存在误判为 True 的可能性）</span>
</span></span></code></pre></div><p>在这个示例中，布隆过滤器使用 mmh3 库来计算哈希值，并使用 bitarray 库来管理位数组。可以根据需要调整位数组的大小和哈希函数的数量，以达到不同的准确性和空间效率。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2015 -
2024
Zen Yu
·</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RYHFS1K5ZH"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RYHFS1K5ZH")</script></body></html>