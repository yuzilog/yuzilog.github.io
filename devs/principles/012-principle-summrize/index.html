<!doctype html><html lang=zh-cn><head><title>012-设计原则总结 · zlog think
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Laoyu"><meta name=description content=" 软件设计原则总结 链接到标题 一、原则定义 链接到标题 在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性。我们需要尽量根据以下7条原则开发程序。提高程序开发效率，降低软件的维护成本。以下对前面学习的设计原则做个简单的汇总。
1、开闭原则
软件实体应当对扩展开放，对修改关闭 2、里氏替换原则
子类可以扩展父类的功能，但不能改变父类原有的功能 3、依赖倒置原则
高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。（ 要面向接口编程，不要面向实现编程） 4、单一职责原则
规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分 5、接口隔离原则
要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用 6、迪米特法则
如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用 7、合成复用原则的定义
要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 二、各个原则其他说明 链接到标题 继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点：
继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 组合或聚合复用优点
它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 "><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="012-设计原则总结"><meta name=twitter:description content=" 软件设计原则总结 链接到标题 一、原则定义 链接到标题 在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性。我们需要尽量根据以下7条原则开发程序。提高程序开发效率，降低软件的维护成本。以下对前面学习的设计原则做个简单的汇总。
1、开闭原则
软件实体应当对扩展开放，对修改关闭 2、里氏替换原则
子类可以扩展父类的功能，但不能改变父类原有的功能 3、依赖倒置原则
高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。（ 要面向接口编程，不要面向实现编程） 4、单一职责原则
规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分 5、接口隔离原则
要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用 6、迪米特法则
如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用 7、合成复用原则的定义
要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 二、各个原则其他说明 链接到标题 继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点：
继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 组合或聚合复用优点
它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 "><meta property="og:url" content="/devs/principles/012-principle-summrize/"><meta property="og:site_name" content="zlog think"><meta property="og:title" content="012-设计原则总结"><meta property="og:description" content=" 软件设计原则总结 链接到标题 一、原则定义 链接到标题 在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性。我们需要尽量根据以下7条原则开发程序。提高程序开发效率，降低软件的维护成本。以下对前面学习的设计原则做个简单的汇总。
1、开闭原则
软件实体应当对扩展开放，对修改关闭 2、里氏替换原则
子类可以扩展父类的功能，但不能改变父类原有的功能 3、依赖倒置原则
高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。（ 要面向接口编程，不要面向实现编程） 4、单一职责原则
规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分 5、接口隔离原则
要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用 6、迪米特法则
如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用 7、合成复用原则的定义
要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 二、各个原则其他说明 链接到标题 继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点：
继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 组合或聚合复用优点
它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 "><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="devs"><meta property="article:published_time" content="2020-09-01T23:54:52+08:00"><meta property="article:modified_time" content="2020-09-01T23:54:52+08:00"><meta property="article:tag" content="Principles"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-webfont/1.7.0/lxgwwenkai-regular.min.css integrity="sha512-Fzvxn9FrR1aKr/Z4Pg9KpnVHCsJoq2QwSu1juU2oQ6wDUkUMk3qQUUWKgFjk0m0LzCamIJVOkg5zeyNX5I1wgA==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=canonical href=/devs/principles/012-principle-summrize/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.06cd8dfa5fcefc340f6510c898bc246ec903c5f7891f6dac9ed2205efc4f98cb.css integrity="sha256-Bs2N+l/O/DQPZRDImLwkbskDxfeJH22sntIgXvxPmMs=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><script src=https://cdnjs.cloudflare.com/ajax/libs/heti/0.9.4/heti-addon.min.js integrity="sha512-GChf2qekcjrSoPicCypQLPqkaZkEnkcsJr85AmkczY0HG5SkfbxOmZY6RoFJLdoeKTGk8EZvkRBaF7BIqV1Ipw==" crossorigin=anonymous referrerpolicy=no-referrer></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/heti/0.9.4/heti.min.css integrity="sha512-/My2cHBMxofuHmAIIK29zje0pIqA2iCC9HDMa76E1jzK5u+wudGzJMMnTsdA5FmVGsoXB1xoJM7fKhniOhz+HA==" crossorigin=anonymous referrerpolicy=no-referrer></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>zlog think
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/readings/>读书</a></li><li class=navigation-item><a class=navigation-link href=/posts/>技术</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于我</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=/devs/principles/012-principle-summrize/>012-设计原则总结</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2020-09-01T23:54:52+08:00>September 1, 2020
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
阅读时间：1 分钟</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/principles/>Principles</a></span></div></div></header><div class=post-content><div class="article-content heti"><h3 id=软件设计原则总结>软件设计原则总结
<a class=heading-link href=#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99%e6%80%bb%e7%bb%93><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><h4 id=一原则定义>一、原则定义
<a class=heading-link href=#%e4%b8%80%e5%8e%9f%e5%88%99%e5%ae%9a%e4%b9%89><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性。我们需要尽量根据以下7条原则开发程序。提高程序开发效率，降低软件的维护成本。以下对前面学习的设计原则做个简单的汇总。</p><p>1、开闭原则</p><ul><li>软件实体应当对扩展开放，对修改关闭</li></ul><p>2、里氏替换原则</p><ul><li>子类可以扩展父类的功能，但不能改变父类原有的功能</li></ul><p>3、依赖倒置原则</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。（ 要面向接口编程，不要面向实现编程）</li></ul><p>4、单一职责原则</p><ul><li>规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</li></ul><p>5、接口隔离原则</p><ul><li>要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用</li></ul><p>6、迪米特法则</p><ul><li>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用</li></ul><p>7、合成复用原则的定义</p><ul><li>要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</li></ul><h4 id=二各个原则其他说明>二、各个原则其他说明
<a class=heading-link href=#%e4%ba%8c%e5%90%84%e4%b8%aa%e5%8e%9f%e5%88%99%e5%85%b6%e4%bb%96%e8%af%b4%e6%98%8e><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p><strong>继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</strong></p><ul><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ul><p><strong>组合或聚合复用优点</strong></p><ul><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ul></div></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2015 -
2025
Laoyu
·</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RYHFS1K5ZH"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RYHFS1K5ZH")</script></body></html>