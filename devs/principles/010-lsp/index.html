<!doctype html><html lang=zh-cn><head><title>010-Liskov-Substitution-Principle · ZLOG Think
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Deshui Yu"><meta name=description content='里氏替换原则（Liskov Substitution Principle，LSP） 链接到标题 里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。
里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。
里氏替换原则的作用 链接到标题 里氏替换原则是实现开闭原则的重要方式之一 它克服了继承中重写父类造成的可复用性变差的缺点 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性 里氏替换原则的实现方法 链接到标题 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。
如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。
如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。
关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。
【例2】里氏替换原则在“几维鸟不是鸟”实例中的应用。
分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行，飞行速度为0km。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期。
如下图一：
package principles import "testing" type Bird struct { flySpeed int } func (b *Bird) SetSpeed(speed int) { b.flySpeed = speed } func (b *Bird) GetFlyTime(distance int) int { return distance / b.'><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="010-Liskov-Substitution-Principle"><meta name=twitter:description content='里氏替换原则（Liskov Substitution Principle，LSP） 链接到标题 里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。
里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。
里氏替换原则的作用 链接到标题 里氏替换原则是实现开闭原则的重要方式之一 它克服了继承中重写父类造成的可复用性变差的缺点 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性 里氏替换原则的实现方法 链接到标题 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。
如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。
如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。
关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。
【例2】里氏替换原则在“几维鸟不是鸟”实例中的应用。
分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行，飞行速度为0km。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期。
如下图一：
package principles import "testing" type Bird struct { flySpeed int } func (b *Bird) SetSpeed(speed int) { b.flySpeed = speed } func (b *Bird) GetFlyTime(distance int) int { return distance / b.'><meta property="og:url" content="/devs/principles/010-lsp/"><meta property="og:site_name" content="ZLOG Think"><meta property="og:title" content="010-Liskov-Substitution-Principle"><meta property="og:description" content='里氏替换原则（Liskov Substitution Principle，LSP） 链接到标题 里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。
里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。
里氏替换原则的作用 链接到标题 里氏替换原则是实现开闭原则的重要方式之一 它克服了继承中重写父类造成的可复用性变差的缺点 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性 里氏替换原则的实现方法 链接到标题 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。
如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。
如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。
关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。
【例2】里氏替换原则在“几维鸟不是鸟”实例中的应用。
分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行，飞行速度为0km。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期。
如下图一：
package principles import "testing" type Bird struct { flySpeed int } func (b *Bird) SetSpeed(speed int) { b.flySpeed = speed } func (b *Bird) GetFlyTime(distance int) int { return distance / b.'><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="devs"><meta property="article:published_time" content="2020-08-26T23:07:52+08:00"><meta property="article:modified_time" content="2020-08-26T23:07:52+08:00"><meta property="article:tag" content="Principles"><meta name=google-adsense-account content="ca-pub-8308665726033207"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-webfont/1.7.0/lxgwwenkai-regular.min.css integrity="sha512-Fzvxn9FrR1aKr/Z4Pg9KpnVHCsJoq2QwSu1juU2oQ6wDUkUMk3qQUUWKgFjk0m0LzCamIJVOkg5zeyNX5I1wgA==" crossorigin=anonymous referrerpolicy=no-referrer><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8308665726033207" crossorigin=anonymous></script><link rel=canonical href=/devs/principles/010-lsp/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.aee8b1681d8ef24f6879fea785c343d719f3bf3ac4619df81b1be22fc6b71351.css integrity="sha256-ruixaB2O8k9oef6nhcND1xnzvzrEYZ34GxviL8a3E1E=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>ZLOG Think
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/readings/>读书</a></li><li class=navigation-item><a class=navigation-link href=/posts/>技术</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于我</a></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=/devs/principles/010-lsp/>010-Liskov-Substitution-Principle</a></h1></header><h3 id=里氏替换原则liskov-substitution-principlelsp>里氏替换原则（Liskov Substitution Principle，LSP）
<a class=heading-link href=#%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%88%99liskov-substitution-principlelsp><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。</p><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><h3 id=里氏替换原则的作用>里氏替换原则的作用
<a class=heading-link href=#%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%88%99%e7%9a%84%e4%bd%9c%e7%94%a8><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><ul><li>里氏替换原则是实现开闭原则的重要方式之一</li><li>它克服了继承中重写父类造成的可复用性变差的缺点</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性</li></ul><h3 id=里氏替换原则的实现方法>里氏替换原则的实现方法
<a class=heading-link href=#%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%88%99%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p><strong>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p><p>关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。</p><p>【例2】里氏替换原则在“几维鸟不是鸟”实例中的应用。</p><p>分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行，飞行速度为0km。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期。</p><p>如下图一：</p><p><img src=https://img.zlog.fun/static/2024-08-22-17-17-53.png alt=2024-08-22-17-17-53></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>principles</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;testing&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Bird</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>flySpeed</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Bird</span><span class=p>)</span> <span class=nf>SetSpeed</span><span class=p>(</span><span class=nx>speed</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>.</span><span class=nx>flySpeed</span> <span class=p>=</span> <span class=nx>speed</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Bird</span><span class=p>)</span> <span class=nf>GetFlyTime</span><span class=p>(</span><span class=nx>distance</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>distance</span> <span class=o>/</span> <span class=nx>b</span><span class=p>.</span><span class=nx>flySpeed</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Swallow</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Bird</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>BrownKiwi</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Bird</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>BrownKiwi</span><span class=p>)</span> <span class=nf>SetSpeed</span><span class=p>(</span><span class=nx>speed</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>.</span><span class=nx>Bird</span><span class=p>.</span><span class=nx>flySpeed</span> <span class=p>=</span> <span class=nx>speed</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestSwallow</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 创建一个燕子
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>swallow</span> <span class=o>:=</span> <span class=nx>Swallow</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>swallow</span><span class=p>.</span><span class=nx>Bird</span><span class=p>.</span><span class=nf>SetSpeed</span><span class=p>(</span><span class=mi>120</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>t</span><span class=p>.</span><span class=nf>Log</span><span class=p>(</span><span class=s>&#34;swallow:&#34;</span><span class=p>,</span> <span class=nx>swallow</span><span class=p>.</span><span class=nf>GetFlyTime</span><span class=p>(</span><span class=mi>600</span><span class=p>),</span> <span class=s>&#34;km/s&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 创建一个kiwi  这个代码会报错，几维鸟不会飞哈哈
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// brownKiwi := BrownKiwi{}
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// brownKiwi.SetSpeed(0)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// t.Log(&#34;brownKiwi:&#34;, brownKiwi.GetFlyTime(600), &#34;km/s&#34;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>输出内容</p><pre tabindex=0><code>=== RUN   TestSwallow
--- PASS: TestSwallow (0.00s)
    lsp_test.go:33: swallow: 5 km/s
PASS
   
panic: runtime error: integer divide by zero [recovered]
	panic: runtime error: integer divide by zero
</code></pre><p>程序运行错误：几维鸟类重写了鸟类的 SetSpeed()方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>principles</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;testing&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Animal</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>runSpeed</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Animal</span><span class=p>)</span> <span class=nf>SetRunSpeed</span><span class=p>(</span><span class=nx>speed</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>.</span><span class=nx>runSpeed</span> <span class=p>=</span> <span class=nx>speed</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Animal</span><span class=p>)</span> <span class=nf>GetRunTime</span><span class=p>(</span><span class=nx>distance</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>distance</span> <span class=o>/</span> <span class=nx>b</span><span class=p>.</span><span class=nx>runSpeed</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Bird</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Animal</span>
</span></span><span class=line><span class=cl>	<span class=nx>flySpeed</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Bird</span><span class=p>)</span> <span class=nf>SetFlySpeed</span><span class=p>(</span><span class=nx>speed</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>.</span><span class=nx>flySpeed</span> <span class=p>=</span> <span class=nx>speed</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Bird</span><span class=p>)</span> <span class=nf>GetFlyTime</span><span class=p>(</span><span class=nx>distance</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>distance</span> <span class=o>/</span> <span class=nx>b</span><span class=p>.</span><span class=nx>flySpeed</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Swallow</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Bird</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>BrownKiwi</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Animal</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestSwallow</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 创建一个燕子
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>swallow</span> <span class=o>:=</span> <span class=nx>Swallow</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>swallow</span><span class=p>.</span><span class=nx>Bird</span><span class=p>.</span><span class=nf>SetFlySpeed</span><span class=p>(</span><span class=mi>120</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>t</span><span class=p>.</span><span class=nf>Log</span><span class=p>(</span><span class=s>&#34;swallow:&#34;</span><span class=p>,</span> <span class=nx>swallow</span><span class=p>.</span><span class=nf>GetFlyTime</span><span class=p>(</span><span class=mi>600</span><span class=p>),</span> <span class=s>&#34;km/s&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 创建一个kiwi
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>brownKiwi</span> <span class=o>:=</span> <span class=nx>BrownKiwi</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>brownKiwi</span><span class=p>.</span><span class=nf>SetRunSpeed</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>t</span><span class=p>.</span><span class=nf>Log</span><span class=p>(</span><span class=s>&#34;brownKiwi:&#34;</span><span class=p>,</span> <span class=nx>brownKiwi</span><span class=p>.</span><span class=nf>GetRunTime</span><span class=p>(</span><span class=mi>600</span><span class=p>),</span> <span class=s>&#34;km/s&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出内容</p><pre tabindex=0><code>=== RUN   TestSwallow
--- PASS: TestSwallow (0.00s)
    lsp_test.go:42: swallow: 5 km/s
    lsp_test.go:47: brownKiwi: 6 km/s
PASS
</code></pre></article></section></div><footer class=footer><section class=container>©
2015 -
2024
Deshui Yu
·</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RYHFS1K5ZH"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RYHFS1K5ZH")</script></body></html>