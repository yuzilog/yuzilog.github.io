<!doctype html><html lang=zh-cn><head><title>008 Dependency Inversion Principle · ZLOG Think
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Deshui Yu"><meta name=description content='依赖倒置原则 链接到标题 依赖倒置原则(DIP)由Robert C. Martin在1996年在 Dependency Inversion Principle中提出，他对此定义如下:
High level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions Robert C. Martin
顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。
程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程。也被称作好莱坞原则：Don’t call me，I will call you.其核心思想是:要面向接口编程，不要面向实现编程。
下面我看一个实例 链接到标题 Example:张三开车的例子，张三是一名司机，可以开不不同品牌的汽车。
// 面向对象设计原则：DIP依赖倒置原则 // 司机可开任何汽车——依赖抽象/接口 // 汽车 Interface type ICar interface { run() } type Camary struct{} func (C Camary) run() { fmt.Println("Camary runing") } type Benz struct{} func (C Benz) run() { fmt.'><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="008 Dependency Inversion Principle"><meta name=twitter:description content='依赖倒置原则 链接到标题 依赖倒置原则(DIP)由Robert C. Martin在1996年在 Dependency Inversion Principle中提出，他对此定义如下:
High level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions Robert C. Martin
顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。
程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程。也被称作好莱坞原则：Don’t call me，I will call you.其核心思想是:要面向接口编程，不要面向实现编程。
下面我看一个实例 链接到标题 Example:张三开车的例子，张三是一名司机，可以开不不同品牌的汽车。
// 面向对象设计原则：DIP依赖倒置原则 // 司机可开任何汽车——依赖抽象/接口 // 汽车 Interface type ICar interface { run() } type Camary struct{} func (C Camary) run() { fmt.Println("Camary runing") } type Benz struct{} func (C Benz) run() { fmt.'><meta property="og:url" content="/devs/principles/008-dependency_inversion_principle/"><meta property="og:site_name" content="ZLOG Think"><meta property="og:title" content="008 Dependency Inversion Principle"><meta property="og:description" content='依赖倒置原则 链接到标题 依赖倒置原则(DIP)由Robert C. Martin在1996年在 Dependency Inversion Principle中提出，他对此定义如下:
High level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions Robert C. Martin
顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。
程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程。也被称作好莱坞原则：Don’t call me，I will call you.其核心思想是:要面向接口编程，不要面向实现编程。
下面我看一个实例 链接到标题 Example:张三开车的例子，张三是一名司机，可以开不不同品牌的汽车。
// 面向对象设计原则：DIP依赖倒置原则 // 司机可开任何汽车——依赖抽象/接口 // 汽车 Interface type ICar interface { run() } type Camary struct{} func (C Camary) run() { fmt.Println("Camary runing") } type Benz struct{} func (C Benz) run() { fmt.'><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="devs"><meta property="article:published_time" content="2020-08-13T22:29:14+08:00"><meta property="article:modified_time" content="2020-08-13T22:29:14+08:00"><meta property="article:tag" content="Principles"><meta name=google-adsense-account content="ca-pub-8308665726033207"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-webfont/1.7.0/lxgwwenkai-regular.min.css integrity="sha512-Fzvxn9FrR1aKr/Z4Pg9KpnVHCsJoq2QwSu1juU2oQ6wDUkUMk3qQUUWKgFjk0m0LzCamIJVOkg5zeyNX5I1wgA==" crossorigin=anonymous referrerpolicy=no-referrer><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8308665726033207" crossorigin=anonymous></script><link rel=canonical href=/devs/principles/008-dependency_inversion_principle/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.aee8b1681d8ef24f6879fea785c343d719f3bf3ac4619df81b1be22fc6b71351.css integrity="sha256-ruixaB2O8k9oef6nhcND1xnzvzrEYZ34GxviL8a3E1E=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>ZLOG Think
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/readings/>读书</a></li><li class=navigation-item><a class=navigation-link href=/posts/>技术</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于我</a></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=/devs/principles/008-dependency_inversion_principle/>008 Dependency Inversion Principle</a></h1></header><h3 id=依赖倒置原则>依赖倒置原则
<a class=heading-link href=#%e4%be%9d%e8%b5%96%e5%80%92%e7%bd%ae%e5%8e%9f%e5%88%99><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>依赖倒置原则(DIP)由Robert C. Martin在1996年在 <a href=http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod class=external-link target=_blank rel=noopener>Dependency Inversion Principle</a>中提出，他对此定义如下:</p><blockquote><p><em>High level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions</em>
<em>Robert C. Martin</em></p><p><em>顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。</em></p></blockquote><p>程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程。也被称作好莱坞原则：Don’t call me，I will call you.其核心思想是:<strong>要面向接口编程，不要面向实现编程。</strong></p><h4 id=下面我看一个实例>下面我看一个实例
<a class=heading-link href=#%e4%b8%8b%e9%9d%a2%e6%88%91%e7%9c%8b%e4%b8%80%e4%b8%aa%e5%ae%9e%e4%be%8b><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p>Example:张三开车的例子，张三是一名司机，可以开不不同品牌的汽车。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 面向对象设计原则：DIP依赖倒置原则
</span></span></span><span class=line><span class=cl><span class=c1>// 司机可开任何汽车——依赖抽象/接口
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 汽车 Interface
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>ICar</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>run</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Camary</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>C</span> <span class=nx>Camary</span><span class=p>)</span> <span class=nf>run</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Camary runing&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Benz</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>C</span> <span class=nx>Benz</span><span class=p>)</span> <span class=nf>run</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Benz runing&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 司机 Interface
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>IDriver</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 司机会驾驶的汽车
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>Ddrive</span><span class=p>(</span><span class=nx>car</span> <span class=nx>ICar</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Driver</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>D</span> <span class=o>*</span><span class=nx>Driver</span><span class=p>)</span> <span class=nf>Ddrive</span><span class=p>(</span><span class=nx>car</span> <span class=nx>ICar</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>D</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>car</span><span class=p>.</span><span class=nf>run</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>调用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestDriver</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>zhangsan</span> <span class=o>:=</span> <span class=nx>principles</span><span class=p>.</span><span class=nx>Driver</span><span class=p>{</span><span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;zhangsan&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>car</span> <span class=o>:=</span> <span class=nx>principles</span><span class=p>.</span><span class=nx>Camary</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>zhangsan</span><span class=p>.</span><span class=nf>Ddrive</span><span class=p>(</span><span class=nx>car</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>car1</span> <span class=o>:=</span> <span class=nx>principles</span><span class=p>.</span><span class=nx>Benz</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>zhangsan</span><span class=p>.</span><span class=nf>Ddrive</span><span class=p>(</span><span class=nx>car1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>---</span>
</span></span><span class=line><span class=cl><span class=o>==</span><span class=p>=</span> <span class=nx>RUN</span>   <span class=nx>TestDriver</span>
</span></span><span class=line><span class=cl><span class=nx>zhangsan</span>
</span></span><span class=line><span class=cl><span class=nx>Camary</span> <span class=nx>runing</span>
</span></span><span class=line><span class=cl><span class=nx>zhangsan</span>
</span></span><span class=line><span class=cl><span class=nx>Benz</span> <span class=nx>runing</span>
</span></span><span class=line><span class=cl><span class=o>---</span> <span class=nx>PASS</span><span class=p>:</span> <span class=nf>TestDriver</span> <span class=p>(</span><span class=mf>0.00</span><span class=nx>s</span><span class=p>)</span>
</span></span></code></pre></div><p>看看以上代码。任意司机可以看任意品牌的汽车，相互之间没有依赖。各汽车之间也可进行定制开发，增加不同的功能。</p><p>满足依赖倒置的原则：</p><ul><li>高层模块不应该依赖低层模块，都应该依赖抽象(接口或抽象类)</li><li>接口或抽象类不应该依赖于实现类</li><li>实现类应该依赖于接口或抽象类</li></ul></article></section></div><footer class=footer><section class=container>©
2015 -
2024
Deshui Yu
·</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RYHFS1K5ZH"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RYHFS1K5ZH")</script></body></html>