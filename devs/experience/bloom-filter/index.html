<!doctype html><html lang=zh-cn><head><title>bloom-filter · zlog think
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Laoyu"><meta name=description content="布隆过滤器（Bloom Filter）是 1970 年由布隆提出的，是一种高效的概率型数据结构。它实际上是一个很长的二进制向量和一系列随机映射函数。用于测试一个元素是否属于一个集合。它特别适用于需要快速检查一个元素是否在一个大集合中的场景。布隆过滤器通过牺牲一定的准确性（存在误判的可能性）来换取空间效率和查询速度。
布隆过滤器简介 链接到标题 优点和缺点 链接到标题 优点 链接到标题 空间效率高：布隆过滤器相比传统的数据结构（如哈希表、集合），在相同的数据量下占用的内存要少得多。 查询速度快：布隆过滤器的查询时间复杂度为 O(k)，其中 k 是哈希函数的数量，通常是常数。 缺点 链接到标题 存在误判：布隆过滤器会存在误判的可能性，即可能会判断一个元素在集合中，但实际并不在。无法判断元素“肯定不存在”的情况。 无法删除元素：一旦元素被添加到布隆过滤器中，无法删除。如果要删除，需要使用改进的版本，如计数布隆过滤器（Counting Bloom Filter）。 应用场景 链接到标题 缓存系统：布隆过滤器常用于缓存系统中，快速判断一个请求是否已经被缓存，以减少不必要的磁盘访问。 网络爬虫：用于判断一个URL是否已经被访问过，避免重复抓取。 数据库：在数据库查询中，用于快速判断一个键值是否存在于数据库中，以减少不必要的查询。 实际实现方式 链接到标题 import mmh3 from bitarray import bitarray class BloomFilter: def __init__(self, size, hash_count): self.size = size self.hash_count = hash_count self.bit_array = bitarray(size) self.bit_array.setall(0) def add(self, item): for i in range(self.hash_count): index = mmh3.hash(item, i) % self.size self.bit_array[index] = 1 def check(self, item): for i in range(self."><meta name=keywords content="blog,developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary"><meta name=twitter:title content="bloom-filter"><meta name=twitter:description content="布隆过滤器（Bloom Filter）是 1970 年由布隆提出的，是一种高效的概率型数据结构。它实际上是一个很长的二进制向量和一系列随机映射函数。用于测试一个元素是否属于一个集合。它特别适用于需要快速检查一个元素是否在一个大集合中的场景。布隆过滤器通过牺牲一定的准确性（存在误判的可能性）来换取空间效率和查询速度。
布隆过滤器简介 链接到标题 优点和缺点 链接到标题 优点 链接到标题 空间效率高：布隆过滤器相比传统的数据结构（如哈希表、集合），在相同的数据量下占用的内存要少得多。 查询速度快：布隆过滤器的查询时间复杂度为 O(k)，其中 k 是哈希函数的数量，通常是常数。 缺点 链接到标题 存在误判：布隆过滤器会存在误判的可能性，即可能会判断一个元素在集合中，但实际并不在。无法判断元素“肯定不存在”的情况。 无法删除元素：一旦元素被添加到布隆过滤器中，无法删除。如果要删除，需要使用改进的版本，如计数布隆过滤器（Counting Bloom Filter）。 应用场景 链接到标题 缓存系统：布隆过滤器常用于缓存系统中，快速判断一个请求是否已经被缓存，以减少不必要的磁盘访问。 网络爬虫：用于判断一个URL是否已经被访问过，避免重复抓取。 数据库：在数据库查询中，用于快速判断一个键值是否存在于数据库中，以减少不必要的查询。 实际实现方式 链接到标题 import mmh3 from bitarray import bitarray class BloomFilter: def __init__(self, size, hash_count): self.size = size self.hash_count = hash_count self.bit_array = bitarray(size) self.bit_array.setall(0) def add(self, item): for i in range(self.hash_count): index = mmh3.hash(item, i) % self.size self.bit_array[index] = 1 def check(self, item): for i in range(self."><meta property="og:url" content="/devs/experience/bloom-filter/"><meta property="og:site_name" content="zlog think"><meta property="og:title" content="bloom-filter"><meta property="og:description" content="布隆过滤器（Bloom Filter）是 1970 年由布隆提出的，是一种高效的概率型数据结构。它实际上是一个很长的二进制向量和一系列随机映射函数。用于测试一个元素是否属于一个集合。它特别适用于需要快速检查一个元素是否在一个大集合中的场景。布隆过滤器通过牺牲一定的准确性（存在误判的可能性）来换取空间效率和查询速度。
布隆过滤器简介 链接到标题 优点和缺点 链接到标题 优点 链接到标题 空间效率高：布隆过滤器相比传统的数据结构（如哈希表、集合），在相同的数据量下占用的内存要少得多。 查询速度快：布隆过滤器的查询时间复杂度为 O(k)，其中 k 是哈希函数的数量，通常是常数。 缺点 链接到标题 存在误判：布隆过滤器会存在误判的可能性，即可能会判断一个元素在集合中，但实际并不在。无法判断元素“肯定不存在”的情况。 无法删除元素：一旦元素被添加到布隆过滤器中，无法删除。如果要删除，需要使用改进的版本，如计数布隆过滤器（Counting Bloom Filter）。 应用场景 链接到标题 缓存系统：布隆过滤器常用于缓存系统中，快速判断一个请求是否已经被缓存，以减少不必要的磁盘访问。 网络爬虫：用于判断一个URL是否已经被访问过，避免重复抓取。 数据库：在数据库查询中，用于快速判断一个键值是否存在于数据库中，以减少不必要的查询。 实际实现方式 链接到标题 import mmh3 from bitarray import bitarray class BloomFilter: def __init__(self, size, hash_count): self.size = size self.hash_count = hash_count self.bit_array = bitarray(size) self.bit_array.setall(0) def add(self, item): for i in range(self.hash_count): index = mmh3.hash(item, i) % self.size self.bit_array[index] = 1 def check(self, item): for i in range(self."><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="devs"><meta property="article:published_time" content="2024-08-21T15:50:05+08:00"><meta property="article:modified_time" content="2024-08-21T15:50:05+08:00"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-webfont/1.7.0/lxgwwenkai-regular.min.css integrity="sha512-Fzvxn9FrR1aKr/Z4Pg9KpnVHCsJoq2QwSu1juU2oQ6wDUkUMk3qQUUWKgFjk0m0LzCamIJVOkg5zeyNX5I1wgA==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=canonical href=/devs/experience/bloom-filter/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.06cd8dfa5fcefc340f6510c898bc246ec903c5f7891f6dac9ed2205efc4f98cb.css integrity="sha256-Bs2N+l/O/DQPZRDImLwkbskDxfeJH22sntIgXvxPmMs=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><script src=https://cdnjs.cloudflare.com/ajax/libs/heti/0.9.4/heti-addon.min.js integrity="sha512-GChf2qekcjrSoPicCypQLPqkaZkEnkcsJr85AmkczY0HG5SkfbxOmZY6RoFJLdoeKTGk8EZvkRBaF7BIqV1Ipw==" crossorigin=anonymous referrerpolicy=no-referrer></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/heti/0.9.4/heti.min.css integrity="sha512-/My2cHBMxofuHmAIIK29zje0pIqA2iCC9HDMa76E1jzK5u+wudGzJMMnTsdA5FmVGsoXB1xoJM7fKhniOhz+HA==" crossorigin=anonymous referrerpolicy=no-referrer></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>zlog think
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/readings/>读书</a></li><li class=navigation-item><a class=navigation-link href=/posts/>技术</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于我</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=/devs/experience/bloom-filter/>bloom-filter</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-08-21T15:50:05+08:00>August 21, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
阅读时间：1 分钟</span></div></div></header><div class=post-content><div class="article-content heti"><p>布隆过滤器（Bloom Filter）是 1970 年由布隆提出的，是一种高效的概率型数据结构。它实际上是一个很长的二进制向量和一系列随机映射函数。用于测试一个元素是否属于一个集合。它特别适用于需要快速检查一个元素是否在一个大集合中的场景。布隆过滤器通过牺牲一定的准确性（存在误判的可能性）来换取空间效率和查询速度。</p><h2 id=布隆过滤器简介>布隆过滤器简介
<a class=heading-link href=#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8%e7%ae%80%e4%bb%8b><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><h2 id=优点和缺点>优点和缺点
<a class=heading-link href=#%e4%bc%98%e7%82%b9%e5%92%8c%e7%bc%ba%e7%82%b9><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><h3 id=优点>优点
<a class=heading-link href=#%e4%bc%98%e7%82%b9><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><ul><li>空间效率高：布隆过滤器相比传统的数据结构（如哈希表、集合），在相同的数据量下占用的内存要少得多。</li><li>查询速度快：布隆过滤器的查询时间复杂度为 O(k)，其中 k 是哈希函数的数量，通常是常数。</li></ul><h3 id=缺点>缺点
<a class=heading-link href=#%e7%bc%ba%e7%82%b9><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><ul><li>存在误判：布隆过滤器会存在误判的可能性，即可能会判断一个元素在集合中，但实际并不在。无法判断元素“肯定不存在”的情况。</li><li>无法删除元素：一旦元素被添加到布隆过滤器中，无法删除。如果要删除，需要使用改进的版本，如计数布隆过滤器（Counting Bloom Filter）。</li></ul><h2 id=应用场景>应用场景
<a class=heading-link href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><ul><li>缓存系统：布隆过滤器常用于缓存系统中，快速判断一个请求是否已经被缓存，以减少不必要的磁盘访问。</li><li>网络爬虫：用于判断一个URL是否已经被访问过，避免重复抓取。</li><li>数据库：在数据库查询中，用于快速判断一个键值是否存在于数据库中，以减少不必要的查询。</li></ul><h2 id=实际实现方式>实际实现方式
<a class=heading-link href=#%e5%ae%9e%e9%99%85%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>mmh3</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>bitarray</span> <span class=kn>import</span> <span class=n>bitarray</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BloomFilter</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>hash_count</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>hash_count</span> <span class=o>=</span> <span class=n>hash_count</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>bit_array</span> <span class=o>=</span> <span class=n>bitarray</span><span class=p>(</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>bit_array</span><span class=o>.</span><span class=n>setall</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>hash_count</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>index</span> <span class=o>=</span> <span class=n>mmh3</span><span class=o>.</span><span class=n>hash</span><span class=p>(</span><span class=n>item</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>bit_array</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>check</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>hash_count</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>index</span> <span class=o>=</span> <span class=n>mmh3</span><span class=o>.</span><span class=n>hash</span><span class=p>(</span><span class=n>item</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>bit_array</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用示例</span>
</span></span><span class=line><span class=cl><span class=n>bf</span> <span class=o>=</span> <span class=n>BloomFilter</span><span class=p>(</span><span class=mi>5000</span><span class=p>,</span> <span class=mi>7</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>bf</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=s2>&#34;hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>bf</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=s2>&#34;world&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>bf</span><span class=o>.</span><span class=n>check</span><span class=p>(</span><span class=s2>&#34;hello&#34;</span><span class=p>))</span>  <span class=c1># 输出: True</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>bf</span><span class=o>.</span><span class=n>check</span><span class=p>(</span><span class=s2>&#34;world&#34;</span><span class=p>))</span>  <span class=c1># 输出: True</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>bf</span><span class=o>.</span><span class=n>check</span><span class=p>(</span><span class=s2>&#34;python&#34;</span><span class=p>))</span> <span class=c1># 输出: False（可能为 False，但存在误判为 True 的可能性）</span>
</span></span></code></pre></div><p>在这个示例中，布隆过滤器使用 mmh3 库来计算哈希值，并使用 bitarray 库来管理位数组。可以根据需要调整位数组的大小和哈希函数的数量，以达到不同的准确性和空间效率。</p></div></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2015 -
2024
Laoyu
·</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-RYHFS1K5ZH"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-RYHFS1K5ZH")</script></body></html>