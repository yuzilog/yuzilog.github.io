<!DOCTYPE html>
<html lang="zh" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>008 Dependency Inversion Principle | Zen Think</title>
<meta name="keywords" content="principles">
<meta name="description" content="依赖倒置原则
依赖倒置原则(DIP)由Robert C. Martin在1996年在 Dependency Inversion Principle中提出，他对此定义如下:

High level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions
Robert C. Martin
顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。

程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程。也被称作好莱坞原则：Don’t call me，I will call you.其核心思想是:要面向接口编程，不要面向实现编程。
下面我看一个实例
Example:张三开车的例子，张三是一名司机，可以开不不同品牌的汽车。
// 面向对象设计原则：DIP依赖倒置原则
// 司机可开任何汽车——依赖抽象/接口

// 汽车 Interface
type ICar interface {
	run()
}

type Camary struct{}

func (C Camary) run() {
	fmt.Println(&#34;Camary runing&#34;)
}

type Benz struct{}

func (C Benz) run() {
	fmt.Println(&#34;Benz runing&#34;)
}

// 司机 Interface
type IDriver interface {
	// 司机会驾驶的汽车
	Ddrive(car ICar)
}

type Driver struct {
	Name string
}

func (D *Driver) Ddrive(car ICar) {
	fmt.Println(D.Name)
	car.run()
}
调用">
<meta name="author" content="Zen Yu">
<link rel="canonical" href="/tech/principles/008-dependency_inversion_principle/">
<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d17904a90dcfff47a9b7967763fe1559eb441fea1c2b3d864916b72bcff26ccf.css" integrity="sha256-0XkEqQ3P/0ept5Z3Y/4VWetEH&#43;ocKz2GSRa3K8/ybM8=" rel="preload stylesheet" as="style">
<link rel="icon" href="/favicon.svg">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/favicon.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="/tech/principles/008-dependency_inversion_principle/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="/tech/principles/008-dependency_inversion_principle/">
  <meta property="og:site_name" content="Zen Think">
  <meta property="og:title" content="008 Dependency Inversion Principle">
  <meta property="og:description" content="依赖倒置原则 依赖倒置原则(DIP)由Robert C. Martin在1996年在 Dependency Inversion Principle中提出，他对此定义如下:
High level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions Robert C. Martin
顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。
程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程。也被称作好莱坞原则：Don’t call me，I will call you.其核心思想是:要面向接口编程，不要面向实现编程。
下面我看一个实例 Example:张三开车的例子，张三是一名司机，可以开不不同品牌的汽车。
// 面向对象设计原则：DIP依赖倒置原则 // 司机可开任何汽车——依赖抽象/接口 // 汽车 Interface type ICar interface { run() } type Camary struct{} func (C Camary) run() { fmt.Println(&#34;Camary runing&#34;) } type Benz struct{} func (C Benz) run() { fmt.Println(&#34;Benz runing&#34;) } // 司机 Interface type IDriver interface { // 司机会驾驶的汽车 Ddrive(car ICar) } type Driver struct { Name string } func (D *Driver) Ddrive(car ICar) { fmt.Println(D.Name) car.run() } 调用">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="tech">
    <meta property="article:published_time" content="2020-08-13T22:29:14+08:00">
    <meta property="article:modified_time" content="2020-08-13T22:29:14+08:00">
    <meta property="article:tag" content="Principles">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="008 Dependency Inversion Principle">
<meta name="twitter:description" content="依赖倒置原则
依赖倒置原则(DIP)由Robert C. Martin在1996年在 Dependency Inversion Principle中提出，他对此定义如下:

High level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions
Robert C. Martin
顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。

程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程。也被称作好莱坞原则：Don’t call me，I will call you.其核心思想是:要面向接口编程，不要面向实现编程。
下面我看一个实例
Example:张三开车的例子，张三是一名司机，可以开不不同品牌的汽车。
// 面向对象设计原则：DIP依赖倒置原则
// 司机可开任何汽车——依赖抽象/接口

// 汽车 Interface
type ICar interface {
	run()
}

type Camary struct{}

func (C Camary) run() {
	fmt.Println(&#34;Camary runing&#34;)
}

type Benz struct{}

func (C Benz) run() {
	fmt.Println(&#34;Benz runing&#34;)
}

// 司机 Interface
type IDriver interface {
	// 司机会驾驶的汽车
	Ddrive(car ICar)
}

type Driver struct {
	Name string
}

func (D *Driver) Ddrive(car ICar) {
	fmt.Println(D.Name)
	car.run()
}
调用">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Teches",
      "item": "/tech/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "008 Dependency Inversion Principle",
      "item": "/tech/principles/008-dependency_inversion_principle/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "008 Dependency Inversion Principle",
  "name": "008 Dependency Inversion Principle",
  "description": "依赖倒置原则 依赖倒置原则(DIP)由Robert C. Martin在1996年在 Dependency Inversion Principle中提出，他对此定义如下:\nHigh level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions Robert C. Martin\n顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。\n程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程。也被称作好莱坞原则：Don’t call me，I will call you.其核心思想是:要面向接口编程，不要面向实现编程。\n下面我看一个实例 Example:张三开车的例子，张三是一名司机，可以开不不同品牌的汽车。\n// 面向对象设计原则：DIP依赖倒置原则 // 司机可开任何汽车——依赖抽象/接口 // 汽车 Interface type ICar interface { run() } type Camary struct{} func (C Camary) run() { fmt.Println(\u0026#34;Camary runing\u0026#34;) } type Benz struct{} func (C Benz) run() { fmt.Println(\u0026#34;Benz runing\u0026#34;) } // 司机 Interface type IDriver interface { // 司机会驾驶的汽车 Ddrive(car ICar) } type Driver struct { Name string } func (D *Driver) Ddrive(car ICar) { fmt.Println(D.Name) car.run() } 调用\n",
  "keywords": [
    "principles"
  ],
  "articleBody": "依赖倒置原则 依赖倒置原则(DIP)由Robert C. Martin在1996年在 Dependency Inversion Principle中提出，他对此定义如下:\nHigh level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions Robert C. Martin\n顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。\n程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程。也被称作好莱坞原则：Don’t call me，I will call you.其核心思想是:要面向接口编程，不要面向实现编程。\n下面我看一个实例 Example:张三开车的例子，张三是一名司机，可以开不不同品牌的汽车。\n// 面向对象设计原则：DIP依赖倒置原则 // 司机可开任何汽车——依赖抽象/接口 // 汽车 Interface type ICar interface { run() } type Camary struct{} func (C Camary) run() { fmt.Println(\"Camary runing\") } type Benz struct{} func (C Benz) run() { fmt.Println(\"Benz runing\") } // 司机 Interface type IDriver interface { // 司机会驾驶的汽车 Ddrive(car ICar) } type Driver struct { Name string } func (D *Driver) Ddrive(car ICar) { fmt.Println(D.Name) car.run() } 调用\nfunc TestDriver(t *testing.T) { zhangsan := principles.Driver{Name: \"zhangsan\"} car := principles.Camary{} zhangsan.Ddrive(car) car1 := principles.Benz{} zhangsan.Ddrive(car1) } --- === RUN TestDriver zhangsan Camary runing zhangsan Benz runing --- PASS: TestDriver (0.00s) 看看以上代码。任意司机可以看任意品牌的汽车，相互之间没有依赖。各汽车之间也可进行定制开发，增加不同的功能。\n满足依赖倒置的原则：\n高层模块不应该依赖低层模块，都应该依赖抽象(接口或抽象类) 接口或抽象类不应该依赖于实现类 实现类应该依赖于接口或抽象类 ",
  "wordCount" : "145",
  "inLanguage": "zh",
  "datePublished": "2020-08-13T22:29:14+08:00",
  "dateModified": "2020-08-13T22:29:14+08:00",
  "author":{
    "@type": "Person",
    "name": "Zen Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/tech/principles/008-dependency_inversion_principle/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Zen Think",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.svg"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo color-title-gradient">
            <a href="/" accesskey="h" title="Zen Think (Alt + H)">Zen Think</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="/tech/" title="Tech">
                    <span>Tech</span>
                </a>
            </li>
            <li>
                <a href="/life/" title="Life">
                    <span>Life</span>
                </a>
            </li>
            <li>
                <a href="/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent color-title-gradient">
      008 Dependency Inversion Principle
    </h1>
    <div class="post-meta"><span title='2020-08-13 22:29:14 +0800 +0800'>2020年8月13日</span>&nbsp;·&nbsp;<span>Zen Yu</span>

</div>
  </header> 
  <div class="post-content"><h3 id="依赖倒置原则">依赖倒置原则<a hidden class="anchor" aria-hidden="true" href="#依赖倒置原则">#</a></h3>
<p>依赖倒置原则(DIP)由Robert C. Martin在1996年在 <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">Dependency Inversion Principle</a>中提出，他对此定义如下:</p>
<blockquote>
<p><em>High level modules should not depend on low level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions</em>
<em>Robert C. Martin</em></p>
<p><em>顶层模块不应该依赖底层模块。这2者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。</em></p>
</blockquote>
<p>程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程。也被称作好莱坞原则：Don’t call me，I will call you.其核心思想是:<strong>要面向接口编程，不要面向实现编程。</strong></p>
<h4 id="下面我看一个实例">下面我看一个实例<a hidden class="anchor" aria-hidden="true" href="#下面我看一个实例">#</a></h4>
<p>Example:张三开车的例子，张三是一名司机，可以开不不同品牌的汽车。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 面向对象设计原则：DIP依赖倒置原则</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 司机可开任何汽车——依赖抽象/接口</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 汽车 Interface</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ICar</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">run</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Camary</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">C</span> <span style="color:#a6e22e">Camary</span>) <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Camary runing&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Benz</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">C</span> <span style="color:#a6e22e">Benz</span>) <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Benz runing&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 司机 Interface</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IDriver</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 司机会驾驶的汽车</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Ddrive</span>(<span style="color:#a6e22e">car</span> <span style="color:#a6e22e">ICar</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Driver</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">D</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Driver</span>) <span style="color:#a6e22e">Ddrive</span>(<span style="color:#a6e22e">car</span> <span style="color:#a6e22e">ICar</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">D</span>.<span style="color:#a6e22e">Name</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">car</span>.<span style="color:#a6e22e">run</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestDriver</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">zhangsan</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">principles</span>.<span style="color:#a6e22e">Driver</span>{<span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;zhangsan&#34;</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">car</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">principles</span>.<span style="color:#a6e22e">Camary</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">zhangsan</span>.<span style="color:#a6e22e">Ddrive</span>(<span style="color:#a6e22e">car</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">car1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">principles</span>.<span style="color:#a6e22e">Benz</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">zhangsan</span>.<span style="color:#a6e22e">Ddrive</span>(<span style="color:#a6e22e">car1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">==</span>= <span style="color:#a6e22e">RUN</span>   <span style="color:#a6e22e">TestDriver</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">zhangsan</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Camary</span> <span style="color:#a6e22e">runing</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">zhangsan</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Benz</span> <span style="color:#a6e22e">runing</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span> <span style="color:#a6e22e">PASS</span>: <span style="color:#a6e22e">TestDriver</span> (<span style="color:#ae81ff">0.00</span><span style="color:#a6e22e">s</span>)
</span></span></code></pre></div><p>看看以上代码。任意司机可以看任意品牌的汽车，相互之间没有依赖。各汽车之间也可进行定制开发，增加不同的功能。</p>
<p>满足依赖倒置的原则：</p>
<ul>
<li>高层模块不应该依赖低层模块，都应该依赖抽象(接口或抽象类)</li>
<li>接口或抽象类不应该依赖于实现类</li>
<li>实现类应该依赖于接口或抽象类</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/principles/">Principles</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="/">Zen Think</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>


<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
